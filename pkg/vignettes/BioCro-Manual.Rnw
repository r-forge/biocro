%\VignetteIndexEntry{Introduction to BioCro}
%\VignettePackage{BioCro}

\documentclass[12pt]{article}

\usepackage{amsmath}
\usepackage{bm}
\usepackage[american]{babel}
\usepackage[authoryear,round]{natbib}
\bibliographystyle{plainnat}
  
\title{Simulation and Parameter Estimation for Biomass Crops}
\author{Fernando E. Miguez\\Department of Agronomy\\
  Iowa State University}
\begin{document}

<<include=FALSE>>=
library(knitr)
opts_chunk$set(include=TRUE,
engine='R',dev='pdf'
)
@

\setkeys{Gin}{width=\textwidth}
\newcommand{\code}[1]{\texttt{\small{#1}}}
\newcommand{\package}[1]{\textsf{\small{#1}}}
\maketitle
\begin{abstract}
Simulation and parameter estimation of photosynthesis and crop growth.
\end{abstract}

<<preliminaries,echo=FALSE>>=
options(width=80)
library(BioCro)
@

\section{Introduction}

The package \package{BioCro} started as a way to continue work on the
ideas developed in the WIMOVAC model. WIMOVAC was developed by Stephen
Long and Steve Humphries
(http://www.life.illinois.edu/plantbio/wimovac/) and there have been
several publications using this model. I have used the model for some
initial efforts at modeling \emph{Miscanthus} $\times$ \emph{giganteus}.

\section{Leaf-level Photosynthesis}
 
There is a large range in the complexity of models that have been used
to simulate photosynthesis. \package{BioCro} offers functions
\code{c4photo} and \code{c3photo}. Both functions take as minimum
input radiation (PAR $\mu mol \; m^-2 \; s^-1$), temperature (Celsius)
and relative humidity (0-1).

Since WIMOVAC originated as a photosynthesis model we can start with a
simple example. For the C$_4$ photosynthesis model the best reference
is Collatz et al. (1992). 

<<ex-photo>>=
c4photo(1500,25,0.7)
@ 

This example shows that with PAR 1500, temperature of 25 and relative
humidity of 0.7 (70\%) as inputs we get simulation of CO$_2$
assimilation (\code{Assim}), stomatal conductance (\code{Gs}) and the
intercellular CO$_2$ (\code{Ci}). For units and other details see
\code{?c4photo}. Another model available for simulating C4
photosynthesis is \code{eC4photo}, see docs for details. This model
has not been used much. In \code{c4photo} the computation is carried
out in compiled \code{C}, but there is a pure R function
\code{c4photoR} which might be useful for understanding the
calculations.

There is an equivalent function \texttt{c3photo} which is closely
based on the c3 photosynthesis model described in WIMOVAC. Notice that
the parameters and interpretation are different from the
\code{c4photo} function. 

<<c4photo, warning=FALSE>>=
pr <- seq(0,2000)
temp <- rep(25, length(pr))
rh <- rep(0.7, length(pr))
res <- c4photo(pr, temp, rh)
plot(pr, res$Assim, ylab="CO2 uptake",xlab="PAR",type='l')
Ca <- seq(15,500)
pr <- rep(1000, length(Ca))
temp <- rep(20, length(Ca))
rh <- rep(0.7, length(Ca))
res <- c4photo(pr,temp,rh,Catm=Ca)
plot(res$Ci, res$Assim, type = 'l', ylab = "CO2 uptake", xlab = "Ci")
@ 

% |

Besides some of the typical parameters for both functions there is the
option of including stress. The argument is \code{stress}. The stress
can be applied to stomatal conductance (default) or $V_{max}$. 

<<c4photo-stress-gs>>=
sws <- seq(0,1,0.01)

assim <- numeric(length(sws))
cond <- numeric(length(sws))
ws <- 'gs'

for(i in 1:length(sws)){

    assim[i] <- c4photo(1500, 25, 0.7, stress=sws[i],ws=ws)$Assim
    cond[i] <- c4photo(1500, 25, 0.7, stress=sws[i],ws=ws)$Gs

}

xyplot(assim + cond ~ sws, type='l', main="stress on gs")
@ 

% | 

<<c4photo-stress-vmax>>=
sws <- seq(0,1,0.01)

assim <- numeric(length(sws))
cond <- numeric(length(sws))
ws <- 'vmax'

for(i in 1:length(sws)){

    assim[i] <- c4photo(1500, 25, 0.7, stress=sws[i],ws=ws)$Assim
    cond[i] <- c4photo(1500, 25, 0.7, stress=sws[i],ws=ws)$Gs

}
xyplot(assim + cond ~ sws, type='l', main="stress on vmax")

@ 

The previous functions are relevant for leaf-level
photosynthesis. Scaling up to the canopy level is not trivial since it
requires developing a light macro environment which simulates the
partitioning between direct and diffuse radiation (see function
\code{lightME}). The function \code{sunML} is used to predict the
proportion of light for each layer of a multiple layered canopy. 

TODO
\begin{itemize}
  \item include an example using \code{c3photo}
  \item Discuss meaning and relationship among parameters
\end{itemize}

\section{Canopy Photosynthesis}

The function \code{CanA} integrates the previous functions
to simulate canopy CO$_2$ assimilation for a complete canopy. This
function also simulates transpiration based on Penman-Monteith, Penman
and Priestly. 

The \code{CanA} function is designed to run at an hourly timestep. The
inputs should all be of length 1. As with other canopy models the
canopy is discretized in layers and each layer has unique conditions
in terms of light levels, leaf temperature, wind and relative
humidity. See \code{?CanA} for details.


<<CanA-onetime>>=
nlay <- 8
res <- CanA(lai=3, doy=200, hr=12, solar=1500, temp=25, rh=0.7, 
            windspeed=2, nlayers=nlay)
@ 

The distribution of leaves in the sun and in the shade is an important
characteristic of a canopy and the architecture can be modified mainly
by changing the \code{chi.l} parameter which represents the ratio of
horizontal leaf projections to vertical leaf projections. 

<<>>=
apply(res$LayMat[,3:4], 2, sum)
@ 

In this example, 1.35 m$^2$ of leaf are in the sun and 1.65 of $m^2$
are in the shade for a total of 3 LAI.

Next we can look in detail about the properties of the canopy by layer

<<multi-layer-canopy, fig.height=4.5, echo=FALSE>>=
data(boo14.200)

lai <- 5
nlay <- 10
chi.l <- 1
lat <- 42
tmp2 <- NULL

for(i in 1:24){
  doy <- boo14.200[i,2]
  hr  <- boo14.200[i,3]
  solar <- boo14.200[i,4]
  temp <- boo14.200[i,5]
  rh <- boo14.200[i,6]
  ws <- boo14.200[i,7]

  tmp <- CanA(lai,doy,hr,solar,temp,rh,ws,
              nlayers=nlay,chi.l=chi.l,
              lat = lat)$LayMat

  tmp <- cbind(hour=hr, layers=1:nlay,tmp)
  tmp2 <- rbind(tmp2,tmp)
     
}

tmpd <- as.data.frame(tmp2)

ttle <- paste("LAI = ",lai,
              "   layers = ",nlay,
              "   chi.l = ",chi.l,
              "   lat = ",lat, sep="")

## Leaf in the Sun and Shade
xyplot(Leafsun + Leafshade ~ hour | factor(layers), type='l',
       xlab = "hour", ylab="Leaf Area (m2/m2)",
       main=ttle, 
       key=simpleKey(text=c("Sun","Shade")),
       data = tmpd, layout=c(nlay,1))

## Transpiration weighted by sun and shade leaf
xyplot(I(TransSun*Leafsun) + 
       I(TransShade*Leafshade) ~ hour | factor(layers), type='l',
       xlab = "hour", ylab="Transpiration (kg/m2/hr)",       
       main=ttle, 
       key=simpleKey(text=c("Sun","Shade")),
       data = tmpd, layout=c(nlay,1))

## Assimilation weighted by sun and shade leaf
xyplot(I(AssimSun*Leafsun) + 
       I(AssimShade*Leafshade) ~ hour | factor(layers), type='l',
       xlab = "hour", ylab="Assimilation (micro mol /m2 ground /s)",
       main=ttle, 
       key=simpleKey(text=c("Sun","Shade")), 
       data = tmpd, layout=c(nlay,1))

## Leaf temperature in the sun and shade
xyplot(DeltaSun + DeltaShade ~ hour | factor(layers), type='l',
       xlab = "hour", ylab="Delta temperature",
       main=ttle, 
       key=simpleKey(text=c("Sun","Shade")), 
       data = tmpd, layout=c(nlay,1))

## Leaf level conductance
xyplot(CondSun + CondShade ~ hour | factor(layers), type='l',
       xlab = "hour", ylab="Conductance (mmol/m2/s)",
       main=ttle, 
       key=simpleKey(text=c("Sun","Shade")), 
       data = tmpd, layout=c(nlay,1))

## Relative humidity profile
xyplot(RH ~ hour | factor(layers), type='l',
       xlab = "hour", ylab="Relative Humidity",
       main=ttle, 
       key=simpleKey(text=c("Sun","Shade")),
       data = tmpd, layout=c(nlay,1))

## Wind speed profile
xyplot(WindS ~ hour | factor(layers), type='l',
       xlab = "hour", ylab="Wind speed (m/s)",
       main=ttle, 
       key=simpleKey(text=c("Sun","Shade")),
       data = tmpd, layout=c(nlay,1))

## Canopy height
xyplot(CanHeight ~ layers, type='l',
       xlab = "layer", ylab="Canopy Height (m)",
       main=ttle, 
       data = tmpd)

@ 

Some important assumption of the multi-layer canopy model are

\begin{itemize}
\item it distributes the LAI equally among layers, this is not
  necessarily a realistic assumption
\item relative humidity increases with canopy depth which causes
  stomatal conductance to increase as well (I don't know what is
  going on in layer 1).
\item by default photosynthetic parameters are constant in the profile
  but it is possible to make them depend on a profile of N
  concentration (see argument \code{lnControl})
\end{itemize}

\subsection{Parameters to adjust}

Which parameters are relevant at the canopy level? Of course
photosythetic parameters are important but these were discussed before
so they are assume to be reasonable here. LAI is a very important
input to this function so it is not really an adjustable parameter.

\begin{itemize}
\item \code{nlayers} The number of layers has an effect on many of the
  results. This can be modified by the user if there is a good
  rationale for doing it. It is possible that taller canopies benefit
  more from having multiple layers and shorter canopies benefit less.
\item \code{kd} extinction coefficient for diffuse light. Although this can be
  calculated it is not at this point.
\item \code{chi.l} is the ratio of horizontal to vertical projection
  of leaf area. Lower than 1 values for more erect canopies and less
  than 1 for canopies with higher proportion of flat leaves.
\item \code{leafwidth} average leaf width. Today(12-12-2014) it does
  not affect any results. Fixme
\item \code{heightFactor} factor relating LAI to height. Adjust it to
  match reasonable height for a crop.
\end{itemize}

\subsection{Calculation of Transpiration}

\code{CanA} simulates transpiration using Priestly (driven by solar
radiation and temperature), Penman (adjusted for the aerodynamic
component) and Penman-Monteith (adjusted for the aerodynamic plus
stomatal component).

<<CanA-Transpiration, echo=FALSE>>=
## Code to test transpiration
data(boo14.200)
dat2 <- NULL
tmp2 <- matrix(ncol=5,nrow=24)
layers <- 10
lai <- 3
doy <- 200
photoP <- photoParms(b1=3)

for(i in 1:24){
         
    hr  <- boo14.200[i,3]
    solar <- boo14.200[i,4]
    temp <- boo14.200[i,5]
    rh <- boo14.200[i,6]
    ws <- boo14.200[i,7]
    
    tmp1 <- CanA(lai,doy,hr,solar,temp,rh,ws,
                 nlayers=layers, photoControl=photoP)

    tmp2[i,1] <- tmp1$CanopyAssim
    tmp2[i,2] <- tmp1$CanopyTrans
    tmp2[i,3] <- tmp1$TranEpen
    tmp2[i,4] <- tmp1$TranEpries
    tmp2[i,5] <- tmp1$CanopyCond
        
    dat1 <- data.frame(hour=i,layer=1:layers, 
                       as.data.frame(tmp1$LayMat))

    dat2 <- rbind(dat2,dat1)
}

tmp2 <- as.data.frame(tmp2)

names(tmp2) <- c("CanopyAssim","CanopyTrans",
                 "TranPen","TranEpries","CanopyCond")

xyplot(CanopyTrans + TranPen + TranEpries ~ 1:24, data = tmp2,
       type='o',
       key= simpleKey(text=c("Penman-Monteith","Penman","Priestly"),
           lines=TRUE, points=FALSE),
           xlab='hour',
           ylab="Transpiration (mm/h)")

apply(tmp2[,2:4], 2, sum)
@ 

The total transpiration for the day is estimated to be highest for the
Priestly method, lowest for the Penman-Monteith and intermediate for
Penman.

\subsection{Effect of Ball-Berry slope parameter}

The slope of the Ball-Berry model can have a significant effect on the
results, but only for the Penman-Monteith method. The parameters for
Ball-Berry however should be set from previous literature data or from
analysis of gas exchange measurements. The purpose of this is to show
that it has a large effect. It is supplied by the \code{photoParms}
function. This increases transpiration in the Penman-Monteith model
but only up to a point.  Priestly and Penman are almost always higher
than Penman-Monteith.

<<include=FALSE>>=
dat2 <- NULL
tmp2 <- matrix(ncol=5,nrow=24)
layers <- 10
lai <- 3
doy <- 200
photoP <- photoParms(b1=3)

for(i in 1:24){
         
    hr  <- boo14.200[i,3]
    solar <- boo14.200[i,4]
    temp <- boo14.200[i,5]
    rh <- boo14.200[i,6]
    ws <- boo14.200[i,7]
    
    tmp1 <- CanA(lai,doy,hr,solar,temp,rh,ws,
                 nlayers=layers, photoControl=photoP)

    tmp2[i,1] <- tmp1$CanopyAssim
    tmp2[i,2] <- tmp1$CanopyTrans
    tmp2[i,3] <- tmp1$TranEpen
    tmp2[i,4] <- tmp1$TranEpries
    tmp2[i,5] <- tmp1$CanopyCond
        
    dat1 <- data.frame(hour=i,layer=1:layers, 
                       as.data.frame(tmp1$LayMat))

    dat2 <- rbind(dat2,dat1)
}

tmp3 <- as.data.frame(tmp2)

names(tmp3) <- c("CanopyAssim","CanopyTrans",
                 "TranPen","TranEpries","CanopyCond")

## Version with higher ball-berry slope
dat2 <- NULL
tmp2 <- matrix(ncol=5,nrow=24)
layers <- 10
lai <- 3
doy <- 200
photoP <- photoParms(b1=7)

for(i in 1:24){
         
    hr  <- boo14.200[i,3]
    solar <- boo14.200[i,4]
    temp <- boo14.200[i,5]
    rh <- boo14.200[i,6]
    ws <- boo14.200[i,7]
    
    tmp1 <- CanA(lai,doy,hr,solar,temp,rh,ws,
                 nlayers=layers, photoControl=photoP)

    tmp2[i,1] <- tmp1$CanopyAssim
    tmp2[i,2] <- tmp1$CanopyTrans
    tmp2[i,3] <- tmp1$TranEpen
    tmp2[i,4] <- tmp1$TranEpries
    tmp2[i,5] <- tmp1$CanopyCond
        
    dat1 <- data.frame(hour=i,layer=1:layers, 
                       as.data.frame(tmp1$LayMat))

    dat2 <- rbind(dat2,dat1)
}

tmp4 <- as.data.frame(tmp2)

names(tmp4) <- c("CanopyAssim","CanopyTrans",
                 "TranPen","TranEpries","CanopyCond")

## Version with even higher ball-berry slope
dat2 <- NULL
tmp2 <- matrix(ncol=5,nrow=24)
layers <- 10
lai <- 3
doy <- 200
photoP <- photoParms(b1=12)

for(i in 1:24){
         
    hr  <- boo14.200[i,3]
    solar <- boo14.200[i,4]
    temp <- boo14.200[i,5]
    rh <- boo14.200[i,6]
    ws <- boo14.200[i,7]
    
    tmp1 <- CanA(lai,doy,hr,solar,temp,rh,ws,
                 nlayers=layers, photoControl=photoP)

    tmp2[i,1] <- tmp1$CanopyAssim
    tmp2[i,2] <- tmp1$CanopyTrans
    tmp2[i,3] <- tmp1$TranEpen
    tmp2[i,4] <- tmp1$TranEpries
    tmp2[i,5] <- tmp1$CanopyCond
        
    dat1 <- data.frame(hour=i,layer=1:layers, 
                       as.data.frame(tmp1$LayMat))

    dat2 <- rbind(dat2,dat1)
}

tmp5 <- as.data.frame(tmp2)

names(tmp5) <- c("CanopyAssim","CanopyTrans",
                 "TranPen","TranEpries","CanopyCond")

@ 

<<echo=FALSE>>=
xyplot(tmp5$CanopyTrans + tmp4$CanopyTrans + tmp3$CanopyTrans + tmp3$TranEpries ~ 1:24,
       type='o', col=c(rep("blue",3),"green"), lty=c(1:3,1),
       key= list(text=list(c("b1=12","b1= 7","b1= 3","Priestly")),
           col=c(rep("blue",3),"green"), 
           lty=c(1:3,1), pch=NA,
           lines=TRUE, points=FALSE, x=0.1, y=0.9),
           xlab='hour',
           ylab="Transpiration (mm/h)")
@ 

\subsection{Parameters to adjust}



TODO
\begin{itemize}
\item Include an example in which I see the effect of stress on
  diurnal transpiration.
\item Include an example in which I see the effect of canopy height on
  diurnal transpiration.
\item Include an example in which I see the effect of changing chi.l
\end{itemize}

\section{Biomass Crop Simulation}

When the interest is to perform a simulation for a whole growing
season, the function \code{BioGro} can be used. This function has as
minimum input weather data for the whole year (365 days) at hourly
time steps. The data can be generated using the \code{weach} function
from daily data.

<<BioGro>>=
data(cmi05)
res <- BioGro(cmi05)
plot(res)
plot(res, plot.kind="SW")
plot(res, plot.kind="ET")
plot(res, plot.kind="cumET")
plot(res, plot.kind="stress")
names(res)
@ 

The last command \code{names(res)} shows the list of objects available
for further manipulation.



\end{document}


\subsection{Parameter Estimation}

This was started with the idea of being able to estimate parameters of
models used to simulate different aspect of the growth of a generic
crop. The model itself is largely based on WIMOVAC although it has
been completely re-written. Thus, this package does not only simulate
growth of crops but is also provides optimization routines for
parameter estimation. In addition, it uses the \package{lattice} for
building custom graphics.

A simple example follows

<<ex1>>=
data(weather05)
res <- BioGro(weather05)
res
@ 

First, an example data set was loaded using the \code{data}
function. Then an object called \code{res} was created which stores
the result of running the function \code{BioGro} with the weather data
as input. The printing method displays only some of the relevant
information of the simulation. The function \code{BioGro} has many
options and the documentation is a good place to start to inquire
further (try \code{?BioGro}).

The plotting method provides a convenient way of displaying the results.

<<plotBioGro, eval=FALSE>>=
plot(res)
@ 
<<echo=FALSE>>=
pdf("./figs/BioCro-plotBioGro.pdf")
plot(res)
dev.off()
@
\begin{figure}[htbp!]
  \centering
  \includegraphics[scale=0.8]{./figs/BioCro-plotBioGro.pdf}
  \caption{Dry biomass accumulation and Leaf Area Index for a generic biomass crop against thermal time.}
  \label{fig:plotBioGro}
\end{figure}

The default plotting option (\texttt{plot.kind}) for the
\texttt{BioGro} option is ``DB'' for dry biomass.  The plot method for
\texttt{BioGro} also has options ``SW'' for soil water, ``ET'' for
evapotranspiration, ``cumET'' for cumulative evapotranspiration and
``stress'' for displaying the stress indexes.

\section{Parameter Estimation}

Often the carbon allocation needs to be modeled from samples of
biomass including stem, leaf, rhizome and root. To evaluate the
ability of the model to recover the `true' coefficients some data were
simulated.

<<op-dbp, eval=FALSE>>=
data(weather05)

## Some coefficients
pheno.ll <- phenoParms(kLeaf1=0.48,kStem1=0.47,kRoot1=0.05,kRhizome1=-1e-4,
                       kLeaf2=0.14,kStem2=0.65,kRoot2=0.21, kRhizome2=-1e-4,
                       kLeaf3=0.01, kStem3=0.56, kRoot3=0.13, kRhizome3=0.3, 
                       kLeaf4=0.01, kStem4=0.56, kRoot4=0.13, kRhizome4=0.3,
                       kLeaf5=0.01, kStem5=0.56, kRoot5=0.13, kRhizome5=0.3,
                       kLeaf6=0.01, kStem6=0.56, kRoot6=0.13, kRhizome6=0.3)

system.time(ans <- BioGro(weather05, phenoControl = pheno.ll))

## Optimization portion
dbp.ll <- phenoParms()
tts6 <- c(1, 500, 1300, 2000, 2600, 3200, 3700)
indx <- BioCro:::indfun(tts6, ans$ThermalT)
                        
ans.dat <- as.data.frame(unclass(ans)[1:11])
sel.rows <- indx
simDat <- ans.dat[sel.rows,c("ThermalT","Stem","Leaf","Root","Rhizome","Grain","LAI")]

## Residual sum of squares before the optimization

ans0 <- BioGro(weather05)
rss0 <- RssBioGro(simDat,ans0) ## 350

idb <- valid_dbp(idbp(simDat))
op1 <- OpBioGro(phen=0, WetDat=weather05, data = simDat, iCoef=idb, op.method="optim")
  
dbp.ll[7:31] <- op1$coefs

ans1 <- BioGro(weather05, phenoControl = dbp.ll)

(rss1 <- RssBioGro(simDat, ans1))
(dist1 <- dist(rbind(op1$coefs,as.vector(unlist(pheno.ll)[7:31]))))
(nconv1 <- length(op1$opar$convergence[op1$opar$convergence == 0]))
@ 


% \section{Simulating Photosynthesis}
% \label{sec:simphoto}

% The package has only two functions at the time. The first one of interest is
% \texttt{c3photo}. Let us see what the arguments for this function are

% <<<argC3photo>>=
% args(c3photo)
% @ 

% \texttt{Qp} is the quantum flux, \texttt{Tl} is the temperature of the
% leaf, \texttt{RH} is the relative humidity, \texttt{vcmax} is the
% maximum rate of carboxylation, \texttt{jmax} is the maximum rate of
% electron transport, \texttt{Rd} is the dark respiration, \texttt{Catm}
% is the atmospheric $CO_2$ concentration, \texttt{O2} is the
% atmospheric oxygen concentration, \texttt{b0} is the intercept of the
% Ball-Berry model, \texttt{b1} is the slope of the Ball-Berry model for
% stomatal conductance and \texttt{theta} is the curvature parameter for
% the light response. For more information see the function
% documentation (i.e. ?c3photo).

% <<C3photo,fig=TRUE,include=FALSE,echo=FALSE>>=
% Qps <- seq(0,2000,10)
% Tls <- seq(0,50,5)
% rhs <- c(0.7)
% dat1 <- data.frame(expand.grid(Qp=Qps,Tl=Tls,RH=rhs))
% res1 <- c3photo(dat1$Qp,dat1$Tl,dat1$RH) 
% res2 <- c3photo(dat1$Qp,dat1$Tl,dat1$RH,vcmax=120)

% plot1 <- xyplot(res1$Assim + res2$Assim ~ Qp | factor(Tl) , data = dat1,
%                type="l",col=c("blue","green"),lwd=2,
%                ylab=expression(paste("Assimilation (",
%                    mu,mol," ",m^-2," ",s^-1,")")),
%                xlab=expression(paste("Quantum flux (",
%                    mu,mol," ",m^-2," ",s^-1,")")),
%                key=list(text=list(c("Vcmax 100","Vcmax 120")),
%                  lines=TRUE,col=c("blue","green"),lwd=2))
% print(plot1)
% @
% \begin{figure}[htbp!]
%   \centering
%   \includegraphics{Intro-C3photo}
%   \caption{Assimilation response to light levels for different
%     temperatures (in Celsius).  Each panel is a different level of
%     temperature. The two lines within a panel show different values
%     for $Vcmax$.}
%   \label{fig:C3photo}
% \end{figure}

% \section{Optimizing Parameters for a single A/Ci curve}

% The other function of interest is \texttt{Opc3photo}. 

% <<Opc3photo>>=
% args(Opc3photo)
% @ 

% The \texttt{data} argument should be the observed assimilation
% data. One example is the built-in dataset \texttt{simA100}.

% <<simA100>>=
% data(simA100)
% head(simA100)
% @ 

% The dataset contains more than is needed to run \texttt{Opc3photo}. We
% know that this dataset was simulated and that the `true' values for
% $Vcmax$, $Jmax$, and $Rd$ are 90.8, 206, and 2.31 respectively. Can we
% recover them from the data alone?

% <<Opc30, eval=FALSE>>=
% Opc3photo(simA100[,1:5],Catm=simA100[,9], curve.kind="Ci", op.level=2)
% @ 
% <<Opc30,echo=FALSE>>=
% tmp <- try(Opc3photo(simA100[,1:5],Catm=simA100[,9], curve.kind="Ci", op.level=2),silent=TRUE)
% @ 
% <<echo=FALSE>>=
% if(class(tmp) == "try-error"){
%   cat(strwrap(tmp), sep="\n")
%   }else{
%     tmp
%     }
% @ 



% This is fabricated data and the function works even if the variance
% seems to be close zero. We can try a slower, less accurate method first to
% get starting values as well. And suppress the computation of the
% hessian.


% <<Opc3photo3>>=
% op100 <- Opc3photo(simA100[,1:5],Catm=simA100[,9], 
%                    method="SANN", hessian=FALSE,
%                    curve.kind="Ci", op.level = 2)
% @ 

% now we can use this values as starting values. If we do not specify
% the optimization method it will use the default used by the
% \texttt{optim} function which is ``Nelder-Mead'' (see \texttt{?optim}).


% <<Opc3photo4>>=
% op100 <- Opc3photo(simA100[,1:5],Catm = simA100[,9], 
%                    ivcmax = op100$bestVmax,
%                    ijmax = op100$bestJmax,
%                    iRd = op100$bestRd,
%                    curve.kind="Ci", op.level=2)
% op100
% @ 

% The small confidence intervals are a result of using fabricated data.
% We can examine the quality of the fit by plotting the residuals. The
% option \texttt{resid} is used to plot `raw' residuals as opposed to
% standardized.

% <<op100resid, eval=FALSE>>=
% plot(op100, resid="raw")
% @ 
% <<echo=FALSE, print=FALSE, term=FALSE>>=
% pdf("./figs/Intro-op100resid.pdf")
% plot(op100, resid="raw")
% dev.off()
% @
% \begin{figure}[htbp!]
%   \centering
%   \includegraphics[scale=0.8]{./figs/Intro-op100resid}
%   \caption{Raw residuals for op100}
%   \label{fig:op100resid}
% \end{figure}

% The residuals show one outlier, but the deviations are
% small. The option \texttt{plot.kind} is used to plot the observed
% vs. fitted.

% <<op100, eval=FALSE>>=
% plot(op100, plot.kind="OvsF")
% plot(op100, plot.kind="OandF", type='o')
% @
% <<op100OvsF, echo=FALSE, print=FALSE, term=FALSE>>=
% pdf("./figs/Intro-op100-OvsF.pdf")
% plot(op100, plot.kind="OvsF")
% dev.off()
% pdf("./figs/Intro-op100-OandF.pdf")
% plot(op100, plot.kind="OandF", type='o')
% dev.off()
% @
% \begin{figure}[htbp!]
%   \centering
%   \includegraphics[scale=0.8]{./figs/Intro-op100-OvsF}  
%   \caption{Observed vs. fitted for the optimization on the simulated data.}
%   \label{fig:ovsf}
% \end{figure}

% \begin{figure}[htbp!]
%   \centering
%   \includegraphics[scale=0.8]{./figs/Intro-op100-OandF}  
%   \caption{Observed and fitted for the optimization on the simulated data.}
%   \label{fig:oandf}
% \end{figure}


% This function can optimize photosynthesis considering assimilation and
% intercellular $CO_2$ both as outputs of the model, but this should be
% done only for `slow-measured' curves. For $A/C_i$ curves the values of
% atmospheric $CO_2$ should also be supplied. The fifth column with
% $C_i$ values is optional. This allows this optimization function to at
% least attempt to optimize any type of photosynthesis data including
% diurnals, temperature response functions and $A/Q$ curves as well. Not
% all data are suitable to estimate the three parameters shown here, so
% the optimization level could also be adjusted.

% \section{Optimizing Parameters for multiple $A/C_i$ curves}

% A wrapper function for \texttt{Opc3photo} called \texttt{mOpc3photo}
% can be used to optimize multiple $A/C_i$ curves which are considered
% multiple `runs'. An example dataset is included.
% \vspace*{0.5cm}

% <<simAssim>>=
% data(simAssim)
% head(simAssim)
% @ 

% These has more than we need, but it contains the `true' values used to
% generate the data so that we can later see if the optimization method
% can recover the `true' values of the parameters. For the optimization
% we need this format.
% \vspace*{0.5cm}

% <<simAssim2>>=
% simAssim2 <- cbind(simAssim[,1:6],Catm=simAssim[,10])
% head(simAssim2)
% parms <- simAssim[seq(1,3600,12),7:9]
% @ 

% The `true' parameters were stored in the parms object.  Now we can run
% the \texttt{mOpc3photo} function.
% \vspace*{0.5cm}

% <<mOpc3photo>>=
% op.all <- mOpc3photo(simAssim2, op.level=2)
% table(op.all[,4])
% @ 

% For the initial run we know that 1 runs did not converge, but this is
% expected as what we want with this first optimization is to get good
% starting values. If some of them did not converge we could replace
% missing values with the mean of each parameter, but this is not needed
% here.  \vspace*{0.5cm}

% <<apply>>=
% colm <- apply(op.all,2,mean,na.rm=TRUE)
% op.all[is.na(op.all[,1]),1] <- colm[1]
% op.all[is.na(op.all[,2]),2] <- colm[2]
% op.all[is.na(op.all[,3]),3] <- colm[3]
% @ 

% Now we can run it again.
% \vspace*{0.5cm}

% <<mOpc3photo2>>=
% op.all2 <- mOpc3photo(simAssim2, iVcmax=op.all[,1], iJmax=op.all[,2], iRd=op.all[,3], op.level=2)
% table(op.all2[,4])
% @ 

% Some of them might not converge, in this case all of them did. We can
% examine if each optimization was able to recover the true values.

% \vspace*{0.5cm}

% <<TvsEparms1,fig=TRUE>>=
% plot(parms[,1],op.all2[,1], ylim=c(70,110), xlim=c(70,110),
%      xlab="Obs (true)",ylab="Sim (est)",main="Vcmax")
% abline(0,1)
% @
% \begin{figure}[htbp!]
%   \centering
%   \includegraphics{Intro-TvsEparms1}
%   \caption{Agreement between true and estimated values for Vcmax}
%   \label{fig:tvseparms1}
% \end{figure}

% \vspace*{0.5cm}

% <<TvsEparms2,fig=TRUE>>=
% plot(parms[,2],op.all2[,2],xlab="Obs (true)",ylab="Sim (est)",main="Jmax")
% abline(0,1)
% @
% \begin{figure}[htbp!]
%   \centering
%   \includegraphics{Intro-TvsEparms2}
%   \caption{Agreement between true and estimated values for Jmax}
%   \label{fig:tvseparms2}
% \end{figure}

% \vspace*{0.5cm}

% <<TvsEparms3,fig=TRUE>>=
% plot(parms[,3],op.all2[,3],xlab="Obs (true)",ylab="Sim (est)",main="Rd")
% abline(0,1)
% @
% \begin{figure}[htbp!]
%   \centering
%   \includegraphics{Intro-TvsEparms3}
%   \caption{Agreement between true and estimated values for Rd}
%   \label{fig:tvseparms3}
% \end{figure}




\end{document}

